// серверные компоненты используются для разгрузки клиентских компонентов и выполнения основной логики на сервере. если использовать какие-то библиотеки на сервере, то они не попадают в бандл, а остаются на сервере. клиентские компоненты выглядят также, как и в реакте, только у них есть первая строка 'use client'.
// !!!Важно:
// - нельзя импортить серверные компоненты внутрь клиентских
// - можно серверные компоненты пробрасывать внутрь клиентских только через пропсы

// Использование:
// 1. клиентские:
// - когда нужны хуки
// - когда нужны события
// - когда нужно браузерное апи (локал сторадж, обзерверы и т.д)
// - когда используется классовый компонент
// 2. серверные:
// - когда получаем данные через серверное апи
// - когда нужен прямой доступ к ресурсам бэка
// - когда используется уязвимая информация (ключи апи, токены и т.д)
// - когда используются тяжелые зависимости

// по ум. в дев режиме используется вебпак. Однако есть более продвинутая штука у next, которая называется turbopack. Чтобы его включить в дев режиме добавляем флаг --turbo

// на данный момент все компоненты, которые мы написали являются серверными. Они более быстродейственны, но в них нельзя использовать стандартные хуки реакта. для того, чтоб сделать компонент клиентским, нужно первой строчкой добавить 'use client'.

// Для создания API-роутов внутри /app директории, как правило, создается вложенная директория /api со своими папками, внутри которых создается файл с названием route.ts.
// Если файл находит по пути /app/api/posts/, то адрес запроса будет /api/posts.
// Сам route.ts должен экспортировать объект с функциями по именам HTTP методов: GET, POST, DELETE и так далее.
// Например:
// export async function GET(req: Request) {
//   return NextResponse.json(currentPosts);
// }

// Извлечение данных:
// получение квери параметров
// export async function GET(req: Request) {
//   const { searchParams } = new URL(req.url);

//   const query = searchParams.get("q");

//   // some logic

//   return NextResponse.json(currentPosts);
// }

// получение тела запроса
// export async function POST(req: Request) {
//   const body = await req.json();

//   console.log(body);

//   return NextResponse.json({ message: "done" });
// }

// получение параметров URL
// export async function DELETE(
//   req: Request,
//   { params }: { params: { id: string } }
// ) {
//   const id = params?.id;

//   // some logic for delete post by id

//   return NextResponse.json({ id });
// }

// Встроенные функции:
// import { headers, cookies } from "next/headers";

// export async function GET(req: Request) {
//   const headersList = headers();
//   const cookiesList = cookies();

//   const type = headersList.get("Content-Type");
//   const Cookie_1 = cookiesList.get("Cookie_1")?.value;

//   return NextResponse.json({});
// }
// import { redirect } from "next/navigation";

// export async function GET(request: Request) {
//   redirect("https://nextjs.org/");
// }

// варианты стратегии рендеринга:
// 1. CRS (client side rendering) - весь рендеринг происходит на клиенте (в браузере). типичен для
//    SPA-приложений. С клиента идет запрос на получение динамических данных, а сервер
//    предоставляет одну или несколько пустых под, которые наполняются динамически. Данный подход не
//    индексируется поисковиками. Подход используется в реакт.
// 2. SSR (server side rendering) - сервер рендерит html-страницу при первом запросе клиента и отправляет ее
//    с некоторым набором JS. на клиенте JS встраивается в html (процесс называется гидрация). При переходе по
//    страницам происходит похожая ситуация, как и в CRS. Но при этом индексируется поисковиками. Подход
//    используется в некст, но по старому методу (через pages).
// 3. RSC (react server components) - содержимое рендерится на сервере и стримится (получение данных
//    кусочками) на клиент без последующей гидрации. Стриминг html-статики происходит не только при первом
//    запросе, но и при переходе на страницы (т.е. при переходах получаем готовую статику каждый раз, а не J
//    S, который потом встраивается в DOM). Индексируется поисковиками. Подход используется в некст (от 13
//    версии) по новому методу (через app).
// 4. SSG (static side generation) - генерация html на сервере, но рендеринг происходит в момент билда, а не
//    в рантайме. Каждая статическая страница не требует гидрации. Подход используется в Gatsby или в некст с
//    определенными настройками (в новом подходе через функцию getStaticParams, в старом подходе через функцию
//    getStaticPath). 
// 5. ISR (incremental static regeneration или revalidating data) - комбинирует в себе SSG и SSR/RSC. позволяет перерендерить статические страницы по какому-то триггеру (таймер или событие). 
